{"mappings":"AGCe,SAAA,EAAsB,CAAG,CAAE,CAAK,CAAE,EAAU,CAAA,CAAK,EAc9D,IAAM,EAAI,EAAW,AAAA,CAAA,GAAK,CAAA,EAAS,GAAK,EAWlC,EAAI,EAAI,EAAI,EAAI,GAAM,EAAI,GAEhC,MAEE,IAAI,EAAI,CACL,GAAG,CAAC,CAAC,EAAG,KAKP,IAAM,EAAI,EAAI,UAAU,CAAC,UAEzB,AAAI,GAAK,IAAM,GAAK,GAWX,OAAO,YAAY,CAAG,AAAA,CAAA,EAAI,GAAK,CAAA,EAAK,GAAM,IAE/C,GAAK,IAAM,GAAK,IAMX,OAAO,YAAY,CAAG,AAAA,CAAA,EAAI,GAAK,CAAA,EAAK,GAAM,IAE5C,CACT,GAEC,IAAI,CAAC,GAEZ,CG/De,eAAA,EAA0B,CAAM,EAC7C,GAAI,CACF,MAAM,UAAU,SAAS,CAAC,SAAS,CAAC,EACtC,CAAE,MAAO,EAAK,CACZ,QAAQ,KAAK,CAAC,mBAAoB,EACpC,CACF,CLAA,EAAE,UAAU,KAAK,CAAC,KAQhB,IAAM,EAAkB,EAAE,iBACpB,EAAiB,EAAE,iBACzB,EAAgB,EAAE,CAAC,QAAS,KAC1B,AAAA,EAAW,EAAgB,IAAI,IAC/B,EAAe,WAAW,CAAC,gBAC3B,EAAe,MAAM,GACrB,WAAW,WACT,EAAe,OAAO,EACxB,EAAG,IACL,GACA,EAAE,wBAAwB,IAAI,GAE9B,IAAM,EAAkB,EAAE,qBAAqB,IAAI,GAE7C,EAAa,EAAE,gBAErB,EAAW,EAAE,CAAC,QAAS,KACrB,AAAA,EAAW,EAAW,IAAI,IAC1B,EAAW,QAAQ,CAAC,SACtB,GAGA,EAAE,mBAAmB,MAAM,CAAC,KAItB,AAAgB,YAFA,EAAE,mBAAmB,GAAG,GAI1C,EAAE,wBAAwB,MAAM,GAGhC,EAAE,wBAAwB,OAAO,EAErC,GAGA,EAAE,gBAAgB,EAAE,CAAC,SAAU,AAAC,IAE9B,EAAE,cAAc,GAEhB,EAAgB,IAAI,GAEpB,EAAW,WAAW,CAAC,UAEvB,EAAW,IAAI,CAAC,IAEhB,IAAM,EAAY,EAAE,eAAe,GAAG,GAIhC,EAAW,SAFG,EAAE,UAAU,GAAG,IAInC,GAAI,AAA+B,YAA/B,EAAE,mBAAmB,GAAG,IAI1B,GIxDJ,AAAI,AAFe,AJ0DH,EI1DS,KAAK,CAAC,KAEhB,MAAM,CAAG,GAAK,AAAoB,CAAA,IAApB,SJwDb,GInDP,EAEF,EJuDI,CACL,IAAM,EAAY,AAAA,EAAa,EAAW,EAAU,CAAA,GACpD,EAAW,IAAI,CAAC,EAClB,KATwB,CAItB,IAAM,EAAY,AAAA,EGpEjB,AAFW,AHoEsB,EGpEf,KAAK,CAAC,KAG5B,GAAG,CAAC,AAAC,GAEG,OAAO,YAAY,CAAC,IAE5B,IAAI,CAAC,IH+DsC,EAAU,CAAA,GAClD,EAAW,IAAI,CAAC,EAClB,MAIK,CAEL,IAAM,EAAa,EAAE,gBAAgB,GAAG,GAElC,EAAe,AAAA,EAAa,EAAW,GAE7C,GAAI,AAAe,YAAf,EAA0B,CAE5B,IAAM,ECnFL,IDmF4C,ECnFpC,CACZ,GAAG,CAAC,CAAC,EAAG,IAEA,ADgFwC,EChFpC,UAAU,CAAC,IAEvB,IAAI,CAAC,KDgFF,EAAW,IAAI,CAAC,EAClB,MACE,EAAW,IAAI,CAAC,EAEpB,CAEA,EAAgB,IAAI,EACtB,EACF","sources":["<anon>","index.js","src/static/alphabetCharCodeArr.js","src/static/caesarCipher.js","src/static/numStrToCharStr.js","src/static/isNumOp.js","src/static/copyResult.js"],"sourcesContent":["// import other scripts\n/** function that gives another layer of\n *  encryption that lets you convert a string cipher\n *  to a sequence of numbers\n */ function $2088ca646ae46537$export$2e2bcd8739ae039(str) {\n    // map over string array and get the character codes\n    return [\n        ...str\n    ].map((l, i)=>{\n        // get the character code\n        return str.charCodeAt(i);\n    }).join(\"-\");\n}\n\n\n// func to decrypt and decrypt strings\nfunction $11c8dc6423395088$export$2e2bcd8739ae039(str, shift, decrypt = false) {\n    /** calculate the effective shift value based on whether decryption is requested\n   *  if decryption is requested, then we can calculate the effective shift\n   *  by subtracting the provided shift value from 26\n   *  and then taking the modulus to ensure the value falls within\n   *  the correct range fo 0-25 -> inclusive 25\n   *  if it is an encryption operation, we simply take the provided\n   *  shift value and return that as s\n   *  EXAMPLE:  if shift is 3 and decryption is requested (decrypt === true)\n   *  s will be calculated as (26 - 3) % 26, resulting in s being 23\n   *  if there is no remainder, modulus returns the num on the left side\n   *  this also means that for decryption, we shift each\n   *  letter in the opposite direction by 23 positions\n   */ const s = decrypt ? (26 - shift) % 26 : shift;\n    /** this line ensures that the shift value is between 0-25\n   *  if the value is already positive, we know it is in the correct\n   *  range and can simply return s\n   *  if it is negative -- which can happen during decryption --\n   *  we add 26 to the value to make sure that we get a valid value\n   *  EXAMPLE: if s is -2 (which might occur during decryption with a shift value of 3)\n   *  n will be calculated as 26 + (-2 % 26), resulting in n being 24\n   *  this ensures that we handle negative shift values correctly\n   *  and keep them within the range of 0 to 25\n   */ const n = s > 0 ? s : 26 + s % 26;\n    // convert the input string to an array of characters and apply the caesar cipher\n    return(// spread original string to individual characters\n    [\n        ...str\n    ].map((l, i)=>{\n        /** get the unicode code of the current character based on index\n         *  we use the index val from the map function to then extract\n         *  the original character from the string\n         */ const c = str.charCodeAt(i);\n        // check if the character is an uppercase letter --> ASCII range 65 to 90\n        if (c >= 65 && c <= 90) /** this part of the expression subtracts the\n           *  unicode value of the character i.e. A --> 65\n           *  from the unicode value of the current character c\n           *  this effectively converts uppercase letters to a zero-based index\n           *  where A is 0, B is 1, and so on\n           *  we can then add the shift value then modulus 26\n           *  to ensure that the index value falls within the appropriate range\n           *  and then add 65 to the result which converts the value back to\n           *  the uppercase equivalent\n           */ return String.fromCharCode((c - 65 + n) % 26 + 65);\n        // check if the character is a lowercase letter --> ASCII range 97 to 122\n        if (c >= 97 && c <= 122) /** apply the caesar cipher transformation for\n           *  lowercase letters and convert back to character\n           *  same process as with upper case characters\n           *  simply reversed\n           */ return String.fromCharCode((c - 97 + n) % 26 + 97);\n        // if the character is not a letter, leave it unchanged\n        return l;\n    })// join the array of characters back into a string\n    .join(\"\"));\n}\n\n\n/** function that decrypts the num string output\n *  back into a string format\n */ function $85bbef809fe3b7a8$export$2e2bcd8739ae039(numStr) {\n    // split the string into an array\n    const numStrArr = numStr.split(\"-\");\n    // map and extract the char code\n    return numStrArr.map((numStr)=>{\n        // get the char\n        return String.fromCharCode(numStr);\n    }).join(\"\");\n}\n\n\n/** helper function to help the\n *  form submit function to determine\n *  what kind of operation to perform\n *  i.e. is it encrypt or decrypt\n *  and what kind of operation\n */ function $f72f0f3fedc517f8$export$2e2bcd8739ae039(input) {\n    /** see if we can split the input\n   *  based on \"-\" which is what the number\n   *  output would be\n   *  if this is the case, it would have length\n   *  higher than 1\n   */ const splitInput = input.split(\"-\");\n    // check length or if it is single number\n    if (splitInput.length > 1 || parseInt(input) === true) /** if this condition is true\n     *  we return true\n     *  otherwise false for text operation\n     */ return true;\n    return false;\n}\n\n\n// helper function to let user copy the final output\nasync function $d6ff56c2549dc244$export$2e2bcd8739ae039(output) {\n    try {\n        await navigator.clipboard.writeText(output);\n    } catch (err) {\n        console.error(\"Failed to copy: \", err);\n    }\n}\n\n\n$(document).ready(()=>{\n    /** hide the output type initially\n   *  which lets the user first choose\n   *  if they want to encrypt or decrypt\n   *  if the val is decrypt, it will\n   *  always return text anyways\n   */ // initialize example tooltip for copying\n    const exampleTestText = $(\".example-test\");\n    const exampleToolTip = $(\"#copy-tooltip\");\n    exampleTestText.on(\"click\", ()=>{\n        (0, $d6ff56c2549dc244$export$2e2bcd8739ae039)(exampleTestText.text());\n        exampleToolTip.removeClass(\"tooltip-hide\");\n        exampleToolTip.fadeIn();\n        setTimeout(function() {\n            exampleToolTip.fadeOut();\n        }, 2000);\n    });\n    $(\"#output-type-section\").hide();\n    // initially hide the output\n    const resultContainer = $(\".result-container\").hide();\n    // select the p tag showing the output\n    const resultText = $(\".result-text\");\n    // add an event listener and helper to copy data\n    resultText.on(\"click\", ()=>{\n        (0, $d6ff56c2549dc244$export$2e2bcd8739ae039)(resultText.text());\n        resultText.addClass(\"copied\");\n    });\n    // event listener to for encrypt-select dropdown\n    $(\"#encrypt-select\").change(()=>{\n        // extract the value of the input\n        const selectedVal = $(\"#encrypt-select\").val();\n        // render if encrypt\n        if (selectedVal === \"encrypt\") // fade in option for output selection\n        $(\"#output-type-section\").fadeIn();\n        else // fade back out if decrypt selected\n        $(\"#output-type-section\").fadeOut();\n    });\n    // set up event listener on form\n    $(\"#cipher-form\").on(\"submit\", (e)=>{\n        // prevent default\n        e.preventDefault();\n        // hide the output again\n        resultContainer.hide();\n        // remove copied class from result\n        resultText.removeClass(\"copied\");\n        // remove any inner text\n        resultText.text(\"\");\n        // extract the text input\n        const textInput = $(\"#text-input\").val();\n        // extract the shift input\n        const shiftValStr = $(\"#shift\").val();\n        // parse int from shift\n        const shiftVal = parseInt(shiftValStr);\n        // check if it is a decrypt or encrypt op\n        if ($(\"#encrypt-select\").val() === \"decrypt\") {\n            /** call the isNumOp function to see whether\n       *  the operation is a num operation or not\n       */ if ((0, $f72f0f3fedc517f8$export$2e2bcd8739ae039)(textInput)) {\n                // get the string from the character codes\n                const strVals = (0, $85bbef809fe3b7a8$export$2e2bcd8739ae039)(textInput);\n                // call the function to decrypt\n                const numResult = (0, $11c8dc6423395088$export$2e2bcd8739ae039)(strVals, shiftVal, true);\n                resultText.text(numResult);\n            } else {\n                const strResult = (0, $11c8dc6423395088$export$2e2bcd8739ae039)(textInput, shiftVal, true);\n                resultText.text(strResult);\n            }\n        } else {\n            // get the output type for encrypt cases\n            const outputType = $(\"#output-type\").val();\n            // encrypt the text input based on the shit and str\n            const encryptedRes = (0, $11c8dc6423395088$export$2e2bcd8739ae039)(textInput, shiftVal);\n            // convert to nums if so chosen\n            if (outputType === \"numbers\") {\n                // call function to return num string\n                const encryptedNumsRes = (0, $2088ca646ae46537$export$2e2bcd8739ae039)(encryptedRes);\n                // return result\n                resultText.text(encryptedNumsRes);\n            } else resultText.text(encryptedRes);\n        }\n        // render the result container\n        resultContainer.show();\n    });\n});\n\n\n//# sourceMappingURL=index.b51d6287.js.map\n","// import other scripts\nimport alphabetCharCodeArr from \"./src/static/alphabetCharCodeArr.js\";\nimport caesarCipher from \"./src/static/caesarCipher.js\";\nimport numStrToCharacter from \"./src/static/numStrToCharStr.js\";\nimport isNumOp from \"./src/static/isNumOp.js\";\nimport copyResult from \"./src/static/copyResult.js\";\n\n$(document).ready(() => {\n  /** hide the output type initially\n   *  which lets the user first choose\n   *  if they want to encrypt or decrypt\n   *  if the val is decrypt, it will\n   *  always return text anyways\n   */\n  // initialize example tooltip for copying\n  const exampleTestText = $(\".example-test\");\n  const exampleToolTip = $(\"#copy-tooltip\");\n  exampleTestText.on(\"click\", () => {\n    copyResult(exampleTestText.text());\n    exampleToolTip.removeClass(\"tooltip-hide\");\n    exampleToolTip.fadeIn();\n    setTimeout(function () {\n      exampleToolTip.fadeOut();\n    }, 2000);\n  });\n  $(\"#output-type-section\").hide();\n  // initially hide the output\n  const resultContainer = $(\".result-container\").hide();\n  // select the p tag showing the output\n  const resultText = $(\".result-text\");\n  // add an event listener and helper to copy data\n  resultText.on(\"click\", () => {\n    copyResult(resultText.text());\n    resultText.addClass(\"copied\");\n  });\n\n  // event listener to for encrypt-select dropdown\n  $(\"#encrypt-select\").change(() => {\n    // extract the value of the input\n    const selectedVal = $(\"#encrypt-select\").val();\n    // render if encrypt\n    if (selectedVal === \"encrypt\") {\n      // fade in option for output selection\n      $(\"#output-type-section\").fadeIn();\n    } else {\n      // fade back out if decrypt selected\n      $(\"#output-type-section\").fadeOut();\n    }\n  });\n\n  // set up event listener on form\n  $(\"#cipher-form\").on(\"submit\", (e) => {\n    // prevent default\n    e.preventDefault();\n    // hide the output again\n    resultContainer.hide();\n    // remove copied class from result\n    resultText.removeClass(\"copied\");\n    // remove any inner text\n    resultText.text(\"\");\n    // extract the text input\n    const textInput = $(\"#text-input\").val();\n    // extract the shift input\n    const shiftValStr = $(\"#shift\").val();\n    // parse int from shift\n    const shiftVal = parseInt(shiftValStr);\n    // check if it is a decrypt or encrypt op\n    if ($(\"#encrypt-select\").val() === \"decrypt\") {\n      /** call the isNumOp function to see whether\n       *  the operation is a num operation or not\n       */\n      if (isNumOp(textInput)) {\n        // get the string from the character codes\n        const strVals = numStrToCharacter(textInput);\n        // call the function to decrypt\n        const numResult = caesarCipher(strVals, shiftVal, true);\n        resultText.text(numResult);\n      } else {\n        const strResult = caesarCipher(textInput, shiftVal, true);\n        resultText.text(strResult);\n      }\n    } else {\n      // get the output type for encrypt cases\n      const outputType = $(\"#output-type\").val();\n      // encrypt the text input based on the shit and str\n      const encryptedRes = caesarCipher(textInput, shiftVal);\n      // convert to nums if so chosen\n      if (outputType === \"numbers\") {\n        // call function to return num string\n        const encryptedNumsRes = alphabetCharCodeArr(encryptedRes);\n        // return result\n        resultText.text(encryptedNumsRes);\n      } else {\n        resultText.text(encryptedRes);\n      }\n    }\n    // render the result container\n    resultContainer.show();\n  });\n});\n","/** function that gives another layer of\n *  encryption that lets you convert a string cipher\n *  to a sequence of numbers\n */\nexport default function alphabetCharCodeArr(str) {\n  // map over string array and get the character codes\n  return [...str]\n    .map((l, i) => {\n      // get the character code\n      return str.charCodeAt(i);\n    })\n    .join(\"-\");\n}\n","// func to decrypt and decrypt strings\nexport default function caesarCipher(str, shift, decrypt = false) {\n  /** calculate the effective shift value based on whether decryption is requested\n   *  if decryption is requested, then we can calculate the effective shift\n   *  by subtracting the provided shift value from 26\n   *  and then taking the modulus to ensure the value falls within\n   *  the correct range fo 0-25 -> inclusive 25\n   *  if it is an encryption operation, we simply take the provided\n   *  shift value and return that as s\n   *  EXAMPLE:  if shift is 3 and decryption is requested (decrypt === true)\n   *  s will be calculated as (26 - 3) % 26, resulting in s being 23\n   *  if there is no remainder, modulus returns the num on the left side\n   *  this also means that for decryption, we shift each\n   *  letter in the opposite direction by 23 positions\n   */\n  const s = decrypt ? (26 - shift) % 26 : shift;\n  /** this line ensures that the shift value is between 0-25\n   *  if the value is already positive, we know it is in the correct\n   *  range and can simply return s\n   *  if it is negative -- which can happen during decryption --\n   *  we add 26 to the value to make sure that we get a valid value\n   *  EXAMPLE: if s is -2 (which might occur during decryption with a shift value of 3)\n   *  n will be calculated as 26 + (-2 % 26), resulting in n being 24\n   *  this ensures that we handle negative shift values correctly\n   *  and keep them within the range of 0 to 25\n   */\n  const n = s > 0 ? s : 26 + (s % 26);\n  // convert the input string to an array of characters and apply the caesar cipher\n  return (\n    // spread original string to individual characters\n    [...str]\n      .map((l, i) => {\n        /** get the unicode code of the current character based on index\n         *  we use the index val from the map function to then extract\n         *  the original character from the string\n         */\n        const c = str.charCodeAt(i);\n        // check if the character is an uppercase letter --> ASCII range 65 to 90\n        if (c >= 65 && c <= 90)\n          /** this part of the expression subtracts the\n           *  unicode value of the character i.e. A --> 65\n           *  from the unicode value of the current character c\n           *  this effectively converts uppercase letters to a zero-based index\n           *  where A is 0, B is 1, and so on\n           *  we can then add the shift value then modulus 26\n           *  to ensure that the index value falls within the appropriate range\n           *  and then add 65 to the result which converts the value back to\n           *  the uppercase equivalent\n           */\n          return String.fromCharCode(((c - 65 + n) % 26) + 65);\n        // check if the character is a lowercase letter --> ASCII range 97 to 122\n        if (c >= 97 && c <= 122)\n          /** apply the caesar cipher transformation for\n           *  lowercase letters and convert back to character\n           *  same process as with upper case characters\n           *  simply reversed\n           */\n          return String.fromCharCode(((c - 97 + n) % 26) + 97);\n        // if the character is not a letter, leave it unchanged\n        return l;\n      })\n      // join the array of characters back into a string\n      .join(\"\")\n  );\n}\n","/** function that decrypts the num string output\n *  back into a string format\n */\nexport default function numStrToCharStr(numStr) {\n  // split the string into an array\n  const numStrArr = numStr.split(\"-\");\n  // map and extract the char code\n  return numStrArr\n    .map((numStr) => {\n      // get the char\n      return String.fromCharCode(numStr);\n    })\n    .join(\"\");\n}\n","/** helper function to help the\n *  form submit function to determine\n *  what kind of operation to perform\n *  i.e. is it encrypt or decrypt\n *  and what kind of operation\n */\nexport default function isNumOp(input) {\n  /** see if we can split the input\n   *  based on \"-\" which is what the number\n   *  output would be\n   *  if this is the case, it would have length\n   *  higher than 1\n   */\n  const splitInput = input.split(\"-\");\n  // check length or if it is single number\n  if (splitInput.length > 1 || parseInt(input) === true) {\n    /** if this condition is true\n     *  we return true\n     *  otherwise false for text operation\n     */\n    return true;\n  }\n  return false;\n}\n","// helper function to let user copy the final output\nexport default async function copyResult(output) {\n  try {\n    await navigator.clipboard.writeText(output);\n  } catch (err) {\n    console.error(\"Failed to copy: \", err);\n  }\n}\n"],"names":["$11c8dc6423395088$export$2e2bcd8739ae039","str","shift","decrypt","s","n","map","l","i","c","charCodeAt","String","fromCharCode","join","$d6ff56c2549dc244$export$2e2bcd8739ae039","output","navigator","clipboard","writeText","err","console","error","$","document","ready","exampleTestText","exampleToolTip","on","text","removeClass","fadeIn","setTimeout","fadeOut","hide","resultContainer","resultText","addClass","change","selectedVal","val","e","preventDefault","textInput","shiftVal","parseInt","splitInput","input","split","length","strResult","numResult","numStrArr","numStr","outputType","encryptedRes","encryptedNumsRes","show"],"version":3,"file":"index.b51d6287.js.map"}